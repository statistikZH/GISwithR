---
title: "GIS mit R"
author: "Thomas Knecht"
date: "15.06.2021"
output:
  html_document:
    css: style.css
    template: zhtemplate.html
---

<script src="js/hideOutput.js"></script>

## Einführung

### Was ist R

R ist eine öffentliche Statistik-Programmiersprache, welche sich für eine breite Anwendung einsetzen lässt.



### Was ist RStudio

RStudio ist in R-Kreisen die bekannteste IDLE. Sie wurde von der Firma RSTudio entwickelt und es gibt eine open-saurce Version.

### Warum R

- open source software
- sehr stark in data wrangling
- unterschiedliche tools, die es dem datenanalysten vereinfachen ganze prozesse selbst zu erstellen ohne andere programmiersprachen zu können
- im statistischen amt weit verbreitet


### GIS mit R

Libraries die auf GDAL zugreiffen

Vektor Libraries:

- sf
- sp

raster libraries:

- stars
- raster

libraries für Visualisierungen:

- ggplot2
- ggmap
- mapview

Buch zur Einführung:

- [Spatial Data Science](https://keen-swartz-3146c4.netlify.app/)


## Ausgangslage

Wir bekommen eine Anfrage der katholischen Kirche, die wissen wollen, 
wie gross der Anteil an über 80 Jährigen in den Kirchgemeinden leben.
Zur Vereinfachung wollen wir die gesamte Bevölkerung miteinbeziehen und nicht nur die katholische.

Wir haben ein Kirchgemeinde Shapefile aus dem Jahr 2019, die Anfragenden wollen 
die Zahlen aber auf dem Kirchgemeindestand 2020 haben.

Vom Jahr 2019 auf das Jahr 2020 hat sich die Kirchgemeinde "Hirzel-Schönenberg-Hütten" getrennt und Hirzel hat sich der Kirchgemeinde Horgen, die anderen zwei der Kirchgemeinde Wädenswil angeschlossen. 

## Berechnung

### Vorbereiten des Setups

Es werden alle packages geladen, welche für die Aufbereitung verwendet werden.
Zudem wird eine Funktion erstellt, welche die Shapefiles auf nicht valide Geometrien untersucht.

```{r, message=FALSE, warning=FALSE}
# Laden aller benötigten Packages
library(sf)
library(dplyr)
library(stringr)
library(dbplyr)
library(ggplot2)
library(ggspatial)
library(mapview)
library(leaflet)

# Hilfsfunktion um die Validität der Geometrien zu prüfen. Falls eine Geometrie kaputt ist, gibt es eine Warnung.
check_validity <- function(sf_df){
  if(FALSE %in% st_is_valid(sf_df)){
    warning("There is an invalid geometry in the Dataset. Use st_make_valid() to repair the geometry.")
  }else{
    print("The geometry is valid.")
  }
}

```

### Importieren der Datensätze

Der Import der Datensätze, in unserem Fall shapefiles, kann mit `st_read()` gemacht werden. Es können aber auch zum Beispiel gpkg, geojson und Daten aus einer DB eingelesen werden. Daten können auch, mit hilfe eines SQL Queries, partiell eingelesen werden.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

# Importieren des Kirchgemeinden-Shapefiles des Jahres 2019
kg <- st_read(paste0("../shapefiles/kirchgemeinden_2019.shp"), stringsAsFactors = FALSE, crs=2056)

# Importieren des Gemeindegrenzen-Shapefiles des Jahres 2020
gem <- st_read(paste0("../shapefiles/gemeinden_2020.shp"), stringsAsFactors = FALSE, crs=2056, query = "SELECT GDE_ID, ART_N FROM \"gemeinden_2020\" ")

```
</div>


### Schauen wir uns die Daten an

Das sf package hat eine eigene plot-Funktion welche fähig ist Karten zu plotten.
Diese ist sehr einfach, es hilft aber um sich einen schnellen Überblich zu verschaffen.
Mit mapview() gibt es eine Funktion, die erlaubt, eine Karte interaktiv anzuschauen.
Dazu wird im backend leaflet verwendet.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}
# statischer Plot
plot(kg$geometry)
```
</div>


```{r, eval=F}
# dynamischer Plot
mapview(kg)
```

### Überprüfen ob die Geometrien der beiden Objekten ok sind

Das sf-package bietet Funktionen an um die Geometrie jedes polygons zu prüfen und zu korrigieren.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

check_validity(kg)
check_validity(gem)

```
</div>

### Erstellen der Kirchgemeindegrenzen für das Jahr 2020


#### Extrahieren der benötigten Polygone

Für das Splitting der Kirchgemeinde, werden die politischen Gemeindegrenzen verwendet.
Also der Teil der Kirchgemeinde, welcher in der politischen Gemeinde Horgen liegt, wird der Kirchgemeinde Horgen zugewiesen, der andere Teil der Kirchgemeinde Wädenswil.
Um den Prozess relativ simple zu halten, extrahiere ich nur die benötigten Polygone.

<div class="fold o">
```{r, fig.show="hold", out.width="50%", message=FALSE, warning=FALSE}
# Filtern der Kirchgemeinde mit der Nummer 19
kg_19 <- kg %>% filter(Kirchnumme == 19)

# Filtern der politischen Gemeinden
gem_h_w <- gem %>% filter(GDE_ID %in% c(293, 295))

ggplot() +
  geom_sf(data = gem_h_w) +
  geom_sf(data = kg_19, color = "red", fill = NA) +
  theme_bw()  +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  coord_sf(datum = NA)

```
</div>

```{r, eval=FALSE}
# interaktive Darstellung
mapview(kg_19, zcol = "ART_TEXT", col.regions = c("red")) + mapview(gem_h_w, zcol = "ART_N")
```


#### Erstellen einer Mapping-Tabelle

Um dann die gesplitteten Polygone den richtigen Kirchgemeinden zuordnen zu können,
wird eine Mapping-Tabelle erstellt.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}
kg_fus_tibble <- tibble(
  GDE_ID = c(293, 295),
  Kirchnumme = c(45, 21),
  GEMEINDENA = c("Wädenswil", "Horgen"),
  ART_TEXT = c("Kirchgemeinde", "Kirchgemeinde"),
  ART_CODE = c(1,1)
)

knitr::kable(kg_fus_tibble)
```
</div>

#### Verschneiden der Kirchgemeinde mit den politischen Gemeinden

Mit dem Verschnitt der beiden Layers wird die Kirchgemeinde in mehrere Polygone unterteilt, welche die ID der darunterliegenden politischen Gemeinden enthalten.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

union_gem <- st_intersection(kg_19, gem_h_w) %>% st_cast("MULTIPOLYGON")

union_single <- st_cast(union_gem, "POLYGON")

knitr::kable(union_single)
```
</div>

#### Zusammenfügen der kleinen Sliver-Polygone mit den grossen Polygonen

Es gibt einige Sliverpolygone, welche den zwei grossen Polygonen zugeordnet werden.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

union_merged <- union_single %>% mutate(area = as.numeric(st_area(.))) %>% 
  mutate(GDE_ID = ifelse(area < 1000, 295, GDE_ID)) %>% 
  group_by(GDE_ID) %>% 
  summarize()

knitr::kable(union_merged)
```
</div>

#### Zuordnen der neuen Kirchgemeinden-ID's zu den neu entstandenen Polygonen

Die neuen Polygone enthalten zur Zeit nur die politische Gemeinde-ID und die alte Kirchennummer. Mit der Mapping-Tabelle werden nun die neuen Kirchgemeinde-ID hinzugefügt.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

new_kirchid <- union_merged %>% 
  left_join(kg_fus_tibble, by = "GDE_ID") %>% 
  select(-GDE_ID)

```
</div>

#### Ersetzten der alten Kirchgemeinden mit den neuen Polygonen und mergen der Kirchgemeinden

Wir ersetzten nun die Kirchgemeinde mit der Nummer 19 durch die zwei neuen Polygone.
Die neuen Polygone werden dann mit den bestehenden Kirchgemeinden gemerged um einheitliche Polygone zu erhalten.

<div class="fold o">
```{r, fig.show="hold", out.width="50%", message=FALSE, warning=FALSE}
kg_2020 <- kg %>% 
  filter(Kirchnumme != 19 | is.na(Kirchnumme)) %>% 
  bind_rows(new_kirchid) %>% 
  st_cast("MULTIPOLYGON") %>% 
  mutate(STICHTAG = "2021-01-01") %>% 
  group_by(ART_TEXT, ART_CODE, STICHTAG, GEMEINDENA, Kirchnumme) %>% 
  summarize()

check_validity(kg_2020)

plot(kg$geometry)
plot(kg_2020$geometry)
```
</div>

So, jetzt haben wir den Kirchgemeindestand vom Jahr 2020.

### Laden der Punktdaten der Bevölkerungsstatistik

Um nun den Anteil der über 80 Jährigen zu berechnen, verwenden wir den OGD-Datensatz der Bevölkerungsstatistik. Da dies Hektardaten sind, ist es lediglich eine Annäherung.
In unserer DB hätten wir Gbäude-Spezifische Daten, um das Beispiel nachspielen zu können, wird hier aber der OGD-Datensatz verwendet.

Da bereits die Anteile auf Hektarraster-Ebene berechnet wurden, müssen wir zuerst die Prozente wieder in Absolute Zahlen umrechnen.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

bevstatistik <- st_read("../shapefiles/bevstatistik_punkte.shp")

bevstatistik_abs <- bevstatistik %>% 
  mutate_at(vars(matches("_P")), ~round(PERS_N/100*.)) %>% 
  rename_at(vars(matches("_P")), ~str_replace_all(., "_P", "_A")) %>% 
  mutate_at(vars(-geometry), ~ifelse(. == 9980 | . == -999, NA, .))

```
</div>

### Zuordnen der Punktdaten zu den Kirchgemeinden

Die Punktdaten und Kirchgemeinden werden verschnitten um dann über die Kirchgemeinde aggregieren zu können.

<div class="fold o">
```{r, cache=TRUE, message=FALSE, warning=FALSE}

bev_within_kg <- st_intersection(bevstatistik_abs, kg_2020)

knitr::kable(head(bev_within_kg, 10))
```
</div>

### Aggregieren der Daten und berechnen des Anteils der über 80 Jährigen an der Bevölkerung in den Kirchgemeinden

Die Punktdaten besitzen nun die Information der Kirchgemeinde und wir können die Daten nach dieser Variable aggregieren. Dann müssen wir noch den Anteil der über 80 Jährigen berechnen.

<div class="fold o">
```{r, message=FALSE, warning=FALSE}

anteil_ue80_pro_kg <- bev_within_kg %>% 
  st_drop_geometry() %>% 
  group_by(Kirchnumme) %>% 
  summarize(anzahl_ue_80 = sum(J_80PLUS_A, na.rm = T),
            anzahl_tot = sum(PERS_N, na.rm = T)) %>% 
  ungroup() %>% 
  mutate(anteil_ue_80 = round(anzahl_ue_80/anzahl_tot*100, 1))


knitr::kable(head(anteil_ue80_pro_kg, 10))
```
</div>

### Joinen der Aggregierten Daten an das Kirchgemeinde-Schapefile und erstellen einer Karte

Die Aggregierten Daten können nun dem Kirchgemeindenshapefile angefügt werden und wir können nun eine Choroplethenkarte erstellen.

<div class="fold o">
```{r, message=FALSE, warning=FALSE, fig.width = 7, fig.align = "center"}

kg_2020_with_anteil <- kg_2020 %>% 
  left_join(anteil_ue80_pro_kg, by = "Kirchnumme") %>% 
  select(Kirchnumme, anteil_ue_80)


#mapview(kg_2020_with_anteil)

ggplot(kg_2020_with_anteil) +
  geom_sf(aes(fill = anteil_ue_80)) +
  theme_bw()  +
  theme(panel.grid.major = element_line(colour = "transparent")) +
  scale_fill_continuous(name = "Anteil ü80 [%]") +
  theme(legend.position = c(0.87, 0.85)) +
  theme(legend.key.size = unit(0.5, 'cm'), #change legend key size
        legend.key.height = unit(0.5, 'cm'), #change legend key height
        legend.key.width = unit(0.5, 'cm'), #change legend key width
        legend.title = element_text(size=9), #change legend title font size
        legend.text = element_text(size=7)) +
  coord_sf(datum = NA) +
  annotation_scale(location = "bl", width_hint = 0.5) +
  annotation_north_arrow(location = "bl", which_north = "true", 
        height = unit(1, "cm"), width = unit(1, "cm"),
        pad_x = unit(0.1, "in"), pad_y = unit(4.2, "in"),
        style = north_arrow_fancy_orienteering)


```
</div>
